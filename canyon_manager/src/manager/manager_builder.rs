use proc_macro2::{TokenStream, Ident, Span};
use quote::quote;

use super::{
    entity::CanyonEntity,
    field_annotation::EntityFieldAnnotation
};

/// Builds the TokenStream that contains the struct definition code
pub fn generate_data_struct(canyon_entity: &CanyonEntity) -> TokenStream {
    let fields = &canyon_entity.get_attrs_as_token_stream();

    let struct_name = &canyon_entity.struct_name;
    let struct_visibility = &canyon_entity.vis;
    let struct_generics = &canyon_entity.generics;

    quote! {
        #struct_visibility struct #struct_name #struct_generics {
            #(#fields),*
        }
    }
}

/// Autogenerated Rust Enum type that contains as many variants
/// with inner value as fields has the structure to which it relates
/// 
/// The type of the inner value `(Enum::Variant(SomeType))` is the same
/// that the field that the variant represents
pub fn generate_enum_with_fields_values(canyon_entity: &CanyonEntity) -> TokenStream {
    let struct_name = canyon_entity.struct_name.to_string();
    let enum_name = Ident::new(
        (struct_name + "FieldValue").as_str(),
        Span::call_site()
    );

    let fields_names = &canyon_entity
        .get_fields_as_enum_variants_with_type();
    let match_arms = &canyon_entity
        .create_match_arm_for_relate_field(&enum_name);

    let visibility = &canyon_entity.vis;
    let generics = &canyon_entity.generics;

    quote! {
        #[derive(Debug)]
        #[allow(non_camel_case_types)]
        /// Autogenerated Rust Enum type for the type #struct_name with every variant
        /// being related to one field that the related struct has
        #visibility enum #enum_name #generics {
            #(#fields_names),*
        }

        impl canyon_sql::bounds::FieldIdentifier for #generics #enum_name #generics {
            fn value(self) -> String {
                match self {
                    #(#match_arms),*
                }
            }
        }

        impl #generics std::fmt::Display for #enum_name #generics {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "") // TODO 
            }
        }
    }
}


/// Helper to debug the attached attributes to a field
pub fn _get_field_attr(entity: &CanyonEntity) -> () {
    let _field_attributes = entity
        .attributes
        .iter()
        .map(|field| {
            match field.attribute {
                Some(EntityFieldAnnotation::ForeignKey(_, _)) => {
                    println!("Annotation ForeignKey found in field: {} for {} entity", 
                        &field.name, &entity.struct_name
                    );
                },
                _ => {
                    println!("No annotation found for field: {} in {} entity", 
                        &field.name, &entity.struct_name
                    );
                },
            };
        })
        .collect::<Vec<_>>();

        ()
}